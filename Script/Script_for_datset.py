# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NB_wfNYi4qy-uoF2zTiLeQ4v6hv7WRwu
"""

import csv
import math

# Function to convert dBm to watts
def dbm_to_watts(dbm):
    return 10 ** ((dbm - 30) / 10)

# Initialize an empty list to store the data
data = []

# Generate data for the "Visibility Range" column (from 0.1 km to 20 km in 0.02 km increments)
visibility_range_values = [0.1 + 0.02 * i for i in range(int((20 - 0.1) / 0.02) + 1)]

# Constants and parameters (all converted to meters)
laser_power_dbm = 2  # Laser power in dBm
laser_power_watts = dbm_to_watts(laser_power_dbm)
diameter_receiving_m = 20 / 100  # Diameter of receiving in meters
diameter_transmitting_m = 5 / 100  # Diameter of transmitting in meters
R_m = 1 * 1000  # Link distance in meters (converted from kilometers)


# Calculate and create data rows
for vis_fs in visibility_range_values:
    # Calculate q_FS based on the provided logic
    if vis_fs > 50:
        q_fs = 1.6
    elif 6 < vis_fs <= 50:
        q_fs = 1.3
    elif 1 < vis_fs <= 6:
        q_fs = 0.67 * vis_fs + 0.34
    elif 0.5 < vis_fs <= 1:
        q_fs = vis_fs + 0.5
    elif vis_fs <= 0.5:
        q_fs = 0
    else:
        q_fs = 0

    # Calculate beta_lambda using the updated formula
    beta_lambda = (3.91 / vis_fs) * (1550 / 550) ** (-q_fs)

    theta_mrad = 2  # Constant value of 2 mrad

    # Calculate power using beta_lambda
    power = (
        laser_power_watts
        * (diameter_receiving_m ** 2)
        * (10 ** (-beta_lambda) * (R_m / 10))
    ) / ((((diameter_transmitting_m) + (theta_mrad / 1000) * R_m)) ** 2)

    response = 1  # Optical responsivity (R_d)
    charge_of_electron=1.60217663e-19
    i_d = 1e-9
    B = 10e9
    T = 273
    k = 1.38e-23  # Boltzmann constant in J/K
    R_load = 1000  # Load resistance in ohms



    # Calculate SNR based on the provided formula
    i_d_squared = 2 * (charge_of_electron * B * i_d ** 2)
    i_th_squared = 2 * (charge_of_electron * power * response)
    i_sh_squared = (4 * k * T * B) / R_load

    SNR = (power * R_m) ** 2 / (i_d_squared + i_th_squared + i_sh_squared)

    data.append([vis_fs, power, SNR])

# Specify the CSV file name
csv_file = "sample.csv"

# Open the CSV file in write mode
with open(csv_file, mode="w", newline="") as file:
    # Create a CSV writer object with column names
    csv_writer = csv.writer(file)
    csv_writer.writerow(["Visibility Range", "Power", "SNR"])  # Header row

    # Write the data to the CSV file row by row
    for row in data:
        csv_writer.writerow(row)

print(f"CSV file '{csv_file}' has been created successfully.")

